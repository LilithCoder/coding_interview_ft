# 回文串
```
首先，寻找回文串是从中间向两端扩展，判断回文串是从两端向中间收缩。对于单链表，无法直接倒序遍历，可以造一条新的反转链表，可以利用链表的后序遍历，也可以用栈结构倒序处理单链表。
具体到回文链表的判断问题，由于回文的特殊性，可以不完全反转链表，而是仅仅反转部分链表，将空间复杂度降到 O(1)。
```
---
[Leetcode Q234](java_src/234.回文链表.java) 回文链表 [分析](https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/pan-duan-hui-wen-lian-biao)
```
就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的，只不过我们利用的是递归函数的堆栈而已。
```

[Leetcode Q9](java_src/9.回文数.java) 9.回文数 
```
计算出数字的后半段的翻转，与前半段的数字比较
```

[Leetcode Q409](java_src/409.最长回文串.java) 409.最长回文串
```
给定字符串，构造最长回文串，在一个回文串中，只有最多一个字符出现了奇数次，其余的字符都出现偶数次。在发现了第一个出现次数为奇数的字符后，我们将 ans 增加 1，这样 ans 变为奇数，在后面发现其它出现奇数次的字符时，我们就不改变 ans 的值了。
```

[Leetcode Q5](java_src/5.最长回文子串.java) 5.最长回文子串
```
给定一个字符串 s，找到 s 中最长的回文子串。
// 这题的思路：
1. 先是暴力，遍历所有子串，如果该子串为回文串，记录长度，找到最长的回文子串
2. 然后再优化，由于回文这个性质很容易想到最优子结构，用动态规划解题
3. 动态规划；定义dp状态，写出状态转移方程，初始化dp，自底向上，将子问题按规模排序
```

[Leetcode Q516](java_src/516.最长回文子序列.java) 516.最长回文子序列
```
给定一个字符串 s，找到 s 中最长回文子序列的长度。
一般涉及到了子序列，考虑的就是动态规划
```

[Leetcode Q125](java_src/125.验证回文串.java) 125.验证回文串
```
遇到验证回文串，用双指针
```

[Leetcode Q680](java_src/680.验证回文字符串Ⅱ.java) 680.验证回文字符串Ⅱ
```
遇到验证回文串，用双指针
```

[Leetcode Q234](java_src/234.回文链表.java) 回文链表 [分析](https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/pan-duan-hui-wen-lian-biao)
```
1. 就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的，只不过我们利用的是递归函数的堆栈而已。

2. 快慢指针遍历+同时翻转前半部分+与后半部分比较
```

131. 分割回文串
132. 分割回文串 II
面试题 01.04. 回文排列
1328. 破坏回文串
336. 回文对
647. 回文子串
266. 回文排列