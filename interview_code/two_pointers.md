# 双指针
>[快慢指针](#快慢指针),
>[左右指针](#左右指针),

[大佬的技术总结](https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/shuang-zhi-zhen-ji-qiao)

## 快慢指针
---
[Leetcode Q141](java_src/141.环形链表.java) 

```
快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。
1、判定链表中是否含有环
这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。
单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。
如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。
但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。
经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。
```
[Leetcode Q142](java_src/142.环形链表II.java) 环形链表 II

```
当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？
第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）
设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。
巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。
所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。
```

[剑指Offer Q22](java_src/剑指Offer22.链表中倒数第k个节点.java) 剑指Offer22.链表中倒数第k个节点

```
我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）
```
## 如何去除有序数组/链表的重复元素
---
[Leetcode Q26](java_src/26.删除排序数组中的重复项.java) 删除排序数组中的重复项
[大佬讲解](https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/ru-he-qu-chu-you-xu-shu-zu-de-zhong-fu-yuan-su)
```
我们的思路还是使用快慢指针，具体看代码和大佬讲解
```

[Leetcode Q83](java_src/83.删除排序链表中的重复元素.java) 删除排序链表中的重复元素
[大佬讲解](https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/ru-he-qu-chu-you-xu-shu-zu-de-zhong-fu-yuan-su)
```
我们的思路还是使用快慢指针，具体看代码和大佬讲解
```


## 左右指针
---
[Leetcode Q167](java_src/167.两数之和II-输入有序数组.java) 两数之和II-输入有序数组

```
只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小
```

[Leetcode Q633](java_src/633.平方数之和.java) 平方数之和

```
可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。
设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。
```

[Leetcode Q345](java_src/345.反转字符串中的元音字母.java) 反转字符串中的元音字母

```
使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。

为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。
```

[Leetcode Q680](java_src/680.验证回文字符串Ⅱ.java) 验证回文字符串Ⅱ

```
使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。

本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。

在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。

在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。
```

[Leetcode Q88](java_src/88.合并两个有序数组.java) 合并两个有序数组

```
需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。
```

[Leetcode Q524](java_src/524.通过删除字母匹配到字典里最长单词.java) 通过删除字母匹配到字典里最长单词
```
用双指针检测一个字符串是否是另一个字符串的子序列
```