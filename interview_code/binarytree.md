# 二叉树

二叉树的套路:
```
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}

TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
}
```

[Leetcode Q236](java_src/236.二叉树的最近公共祖先.java) 二叉树的最近公共祖先 [大佬分析](https://mp.weixin.qq.com/s/9RKzBcr3I592spAsuMH45g)
```
二叉树的递归
```

[Leetcode Q222](java_src/222.完全二叉树的节点个数.java) 完全二叉树的节点个数 [大佬分析](https://mp.weixin.qq.com/s/xW2fbE3v4JhMSKfxoxIHBg)
```
如果是一个普通二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：

public int countNodes(TreeNode root) {
    if (root == null) return 0;
    return 1 + countNodes(root.left) + countNodes(root.right);
}
那如果是一棵满二叉树，节点总数就和树的高度呈指数关系，时间复杂度 O(logN)：

public int countNodes(TreeNode root) {
    int h = 0;
    // 计算树的高度
    while (root != null) {
        root = root.left;
        h++;
    }
    // 节点总数就是 2^h - 1
    return (int)Math.pow(2, h) - 1;
}
完全二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：
public int countNodes(TreeNode root) {
    TreeNode l = root, r = root;
    // 记录左、右子树的高度
    int hl = 0, hr = 0;
    while (l != null) {
        l = l.left;
        hl++;
    }
    while (r != null) {
        r = r.right;
        hr++;
    }
    // 如果左右子树的高度相同，则是一棵满二叉树
    if (hl == hr) {
        return (int)Math.pow(2, hl) - 1;
    }
    // 如果左右高度不同，则按照普通二叉树的逻辑计算
    return 1 + countNodes(root.left) + countNodes(root.right);
}
一棵完全二叉树的两棵子树，至少有一棵是满二叉树：
```

[Leetcode Q94](java_src/94.二叉树的中序遍历.java) 94.二叉树的中序遍历
```
二叉树的中序遍历, 迭代方式
```

[Leetcode Q145](java_src/145.二叉树的后序遍历.java) 145.二叉树的后序遍历
```
二叉树的后序遍历, 迭代方式
```

[Leetcode Q144](java_src/144.二叉树的前序遍历.java) 144.二叉树的前序遍历
```
二叉树的前序遍历, 迭代方式
```

[Leetcode Q102](java_src/102.二叉树的层序遍历.java) 102.二叉树的层序遍历
```
二叉树的层序遍历 bfs
```

[Leetcode Q103](java_src/103.二叉树的锯齿形层次遍历.java) 103.二叉树的锯齿形层次遍历
```
二叉树的锯齿形层次遍历 bfs
```

[Leetcode Q987](java_src/987.二叉树的垂序遍历.java) 987.二叉树的垂序遍历
```
dfs+排序
```

[Leetcode Q429](java_src/429.N叉树的层序遍历.java) 429.N叉树的层序遍历
```
bfs
```

[Leetcode Q589](java_src/589.N叉树的前序遍历.java) 589.N叉树的前序遍历
```
N叉树的前序遍历
```

[Leetcode Q590](java_src/590.N叉树的后序遍历.java) 590.N叉树的后序遍历
```
N叉树的后序遍历
```

[Leetcode Q105](java_src/105.从前序与中序遍历序列构造二叉树.java) 105.从前序与中序遍历序列构造二叉树
```
只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。

这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。
```

[Leetcode Q655](java_src/655.输出二叉树.java) 655.输出二叉树
```
二叉树的递归
```

[Leetcode Q104](java_src/104.二叉树的最大深度.java) 104.二叉树的最大深度
```
二叉树的递归
```

[Leetcode Q101](java_src/101.对称二叉树.java) 101.对称二叉树
```
二叉树的递归
```

[Leetcode Q257](java_src/257.二叉树的所有路径.java) 257.二叉树的所有路径
```
回溯算法
```

[Leetcode Q112](java_src/112.路径总和.java) 112.路径总和
```
二叉树的递归
```

[Leetcode Q113](java_src/113.路径总和II.java) 113.路径总和II
```
回溯算法
```

[Leetcode Q437](java_src/437.路径总和III.java) 437.路径总和III
```
双重递归、回溯算法
```

[Leetcode Q124](java_src/124.二叉树中的最大路径和.java) 124.二叉树中的最大路径和
```
    二叉树递归
    // 本题思路：
    // 每一个经过当前递归root结点的最大路径和是max(左子树的最大贡献值，右子树的最大贡献值)+当前root的值
    // 这个路径能路过的顶峰就是root
    // 最大贡献值是当前子树的root结点开始向下最大路径和
    // 每次递归返回的是最大贡献值，然后维持一个变量来记录经过当前递归root结点的最大路径和
```

[Leetcode Q1038](java_src/1038.把二叉搜索树转换为累加树.java) 1038.把二叉搜索树转换为累加树
```
    // 本题思路：
    // 访问每一个节点时，我们希望有一个变量 sum，存了「比当前节点值大的所有节点值的和」。
    // 反向的中序遍历，访问的节点值是递减的，之前访问的节点值都比当前的大，每次累加给sum，sum就会存下所有比自己大的节点值之和。
    // 遍历完会得到返回树，所以有返回值TreeNode
```

[Leetcode Q543](java_src/543.二叉树的直径.java) 543.二叉树的直径
```
    // 本题思路：
    // dfs，每次递归的root计算当前root开始向下的最长路径(包括root本身)
    // 二叉树直径就为root的左子树的递归值+右子树的递归值+1
```

[Leetcode Q114](java_src/114.二叉树展开为链表.java) 114.二叉树展开为链表
```
    // 本题思路：
    // 将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。
    // 因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。
    // 由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。
```

[Leetcode Q226](java_src/226.翻转二叉树.java) 226.翻转二叉树
```
    // 本题思路：
    // 我们从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。
    // 如果当前遍历到的节点root的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以root为根节点的整棵子树的翻转。
```

[Leetcode Q108](java_src/108.将有序数组转换为二叉搜索树.java) 108.将有序数组转换为二叉搜索树
```
    // 本题思路：
    // BST的中序遍历是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树
    // 因此我们可以以升序序列中的任一个元素作为根节点
    // 以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树
    // 又因为本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点
```

[Leetcode Q109](java_src/109.有序链表转换二叉搜索树.java) 109.有序链表转换二叉搜索树
```
    // 本题思路：
    // 这题和lc108差不多，只不过链表找中点费事了一些
    // BST的中序遍历是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树
    // 因此我们可以以升序序列中的任一个元素作为根节点
    // 以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树
    // 又因为本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点
```

[Leetcode Q230](java_src/230.二叉搜索树中第K小的元素.java) 230.二叉搜索树中第K小的元素
```
    // 本题思路：
    // 中序遍历：遍历到第k个元素的时候返回值
```

[剑指Offer33](java_src/剑指Offer33.二叉搜索树的后序遍历序列.java) 剑指Offer33.二叉搜索树的后序遍历序列
```
    // 本题思路：
    // 后序遍历定义： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。
    // 二叉搜索树定义： 左子树中所有节点的值 < 根节点的值；右子树中所有节点的值 > 根节点的值；其左、右子树也分别为二叉搜索树。
```

[剑指Offer68](java_src/剑指Offer68-I.二叉搜索树的最近公共祖先.java) 剑指Offer68-I.二叉搜索树的最近公共祖先
```
    // 本题思路：
    // p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
    // p=root，且 q 在 root 的左或右子树中；
    // q=root，且 p 在 root 的左或右子树中；
```

[剑指Offer54](java_src/剑指Offer54.二叉搜索树的第k大节点.java) 剑指Offer54.二叉搜索树的第k大节点
```
    // 本题思路：
    // 反向中序遍历，得到第k个元素
```

[剑指Offer34](java_src/剑指Offer34.二叉树中和为某一值的路径.java) 剑指Offer34.二叉树中和为某一值的路径
```
    // 本题思路：
    // 回溯算法，遍历每个可能的路径，符合条件加入res
```

[剑指Offer68](java_src/剑指Offer68-II.二叉树的最近公共祖先.java) 剑指Offer68-II.二叉树的最近公共祖先
```
    // 本题思路：
    // 两个节点 p,q 分为两种情况：
    // p 和 q 在相同子树中
    // p 和 q 在不同子树中
    // 从根节点遍历，递归向左右子树查询节点信息
    // 递归终止条件：如果当前节点为空或等于 p 或 q，则返回当前节点
    // 递归遍历左右子树，如果左右子树查到节点都不为空，则表明 p 和 q 分别在左右子树中，因此，当前节点即为最近公共祖先；
    // 如果左右子树其中一个不为空，则返回非空节点。
```

[剑指Offer55](java_src/剑指Offer55-I.二叉树的深度.java) 剑指Offer55-I.二叉树的深度
```
    // 本题思路：
    // 递归
```

[剑指Offer55](java_src/剑指Offer27.二叉树的镜像.java) 剑指Offer27.二叉树的镜像
```
    // 本题思路：
    // 我们从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。
    // 如果当前遍历到的节点root的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以root为根节点的整棵子树的翻转。
```

[剑指Offer32](java_src/剑指Offer32-I.从上到下打印二叉树.java) 剑指Offer32-I.从上到下打印二叉树
```
    // 本题思路：
    // bfs
```

[剑指Offer18](java_src/剑指Offer18.删除链表的节点.java) 剑指Offer18.删除链表的节点
```
    // 本题思路：
    // 删除链表中的元素，需要用dummy head来处理删除头结点的问题
```

[剑指Offer28](java_src/剑指Offer28.对称的二叉树.java) 剑指Offer28.对称的二叉树
```
    // 本题思路：
    // 递归, 当二叉树的左右子树对称，该二叉树对称
    // 当左右子树的root相同，且左子树的左子树和右子树的右子树对称，且左子树的右子树和右子树的左子树对称，则对称
```

[剑指Offer55-II](java_src/剑指Offer55-II.平衡二叉树.java) 剑指Offer55-II.平衡二叉树
```
    // 本题思路：
    // 弄个辅助函数测二叉树的左右树高
    // 一旦左右树高大于1，则不平衡
```

[剑指Offer37](java_src/剑指Offer37.序列化二叉树.java) 剑指Offer37.序列化二叉树
```
    // 本题思路：
    // 层序遍历
    // 序列化，反序列化
```

[剑指Offer26](java_src/剑指Offer26.树的子结构.java) 剑指Offer26.树的子结构
```
    // 本题思路：
    // 先序遍历树 A 中的每个节点 n_A ；（对应函数 isSubStructure(A, B)）
    // 判断树 A 中 以 n_A 为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）
```

[剑指Offer07](java_src/剑指Offer07.重建二叉树.java) 剑指Offer07.重建二叉树
```
直接看代码
```
230. 二叉搜索树中第K小的元素
236. 二叉树的最近公共祖先
235. 二叉搜索树的最近公共祖先
297. 二叉树的序列化与反序列化
428. 序列化和反序列化 N 叉树
543. 二叉树的直径
199. 二叉树的右视图
100. 相同的树
700. 二叉搜索树中的搜索
98. 验证二叉搜索树
701. 二叉搜索树中的插入操作
450. 删除二叉搜索树中的节点
108. 将有序数组转换为二叉搜索树