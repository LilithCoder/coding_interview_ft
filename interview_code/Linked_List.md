# Linked_List
>[链表高精度加法](#链表高精度加法),
>[链表的旋转与反转](#链表的旋转与反转),
>[链表的合并](#链表的合并)

## 链表高精度加法
---
[Leetcode Q2](java_src/2.两数相加.java) Add Two Numbers (两数相加)
> ByteDance, Huawei
```
Using the linkedlist to add two numbers. It is necessary to notice edge cases: null, carry
```
![Alt text](pic/q2_1.png)
![Alt text](pic/q2_2.png)

## 链表的旋转与反转
---
[Leetcode Q206](java_src/206.反转链表.java) Reverse Linked List (反转链表)
> ByteDance, amazon, tencent
```
迭代: 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。最后返回新的头引用

递归：想要先对链表尾操作，应该在对当前结点操作之前调用递归。
我子节点下的所有节点都已经反转好了，现在就剩我和我的子节点 没有完成最后的反转了，所以反转一下我和我的子节点。
如果 head 为空或者 head.next 为空，则说明没有节点或者只有一个节点了，返回本节点即可。
假设链表为1，2，3，4，5。按照递归，当执行reverseList（5）的时候返回了5这个节点，reverseList(4)中的p就是5这个节点，我们看看reverseList（4）接下来执行完之后，5->next = 4, 4->next = null。这时候返回了p这个节点，也就是链表5->4->null，接下来执行reverseList（3），代码解析为4->next = 3,3->next = null，这个时候p就变成了，5->4->3->null, reverseList(2), reverseList(1)依次类推，p就是:5->4->3->2->1->null
```

[Leetcode Q92](java_src/92.反转链表-ii.java) 反转链表 ii
```
顺序遍历m到n
// t  c
// 1->2->3->4->5
// t     c
// 1->3->2->4->5
// t        c
// 1->4->3->2->5
```

[Leetcode Q25](java_src/25.K个一组翻转链表.java) K个一组翻转链表
```
递归翻转链表
```

## 链表的合并
---
[Leetcode Q21](java_src/21.合并两个有序链表.java) 合并两个有序链表
```
合并连个有序链表，用递归和迭代的方法，分治策略里归并的步骤！
```

[Leetcode Q23](java_src/23.合并K个排序链表.java) 合并K个排序链表
```
用分治的方法进行合并。分治的策略：edge case->divide->conquer->combine，分治时候function的参数需要start end
顺序合并: 按顺序依次merge two lists
优先序列：将每个list的头结点（最小的）加入优先队列，每次remove的就是最小的node，一旦remove了就这个结点后面next的node之后全部遍历完
```

[Leetcode Q160](java_src/160.相交链表.java) 160.相交链表
```
设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。
```

[Leetcode Q19](java_src/19.删除链表的倒数第N个节点.java) 19.删除链表的倒数第N个节点
```
快慢指针，快指针先走n步，然后快慢一起走，直到快指针走到最后，要注意的是可能是要删除第一个节点，这个时候可以直接返回head.next
```

[Leetcode Q24](java_src/24.两两交换链表中的节点.java) 两两交换链表中的节点
```
看代码
```

[Leetcode Q725](java_src/725.分隔链表.java) 725.分隔链表
```
看代码
```

[Leetcode Q148](java_src/148.排序链表.java) 148.排序链表
```
看代码
```

[Leetcode Q21](java_src/21.合并两个有序链表.java) 合并两个有序链表
```
合并连个有序链表，用递归和迭代的方法，分治策略里归并的步骤！
```

[Leetcode Q23](java_src/23.合并K个排序链表.java) 合并K个排序链表
```
用分治的方法进行合并。分治的策略：edge case->divide->conquer->combine，分治时候function的参数需要start end
顺序合并: 按顺序依次merge two lists
优先序列：将每个list的头结点（最小的）加入优先队列，每次remove的就是最小的node，一旦remove了就这个结点后面next的node之后全部遍历完
```

---
[剑指Offer06.从尾到头打印链表](java_src/剑指Offer06.从尾到头打印链表.java) 剑指Offer06.从尾到头打印链表
```
用递归的方式逆向遍历链表
```

[Leetcode Q61](java_src/61.旋转链表.java) 61.旋转链表
```
快慢指针，让快针先走k步，然后快慢指针一起遍历直到链表尾部
快慢指针之间的部分链表为需要旋转的部分，改下各个指针的指向
```

[Leetcode Q328](java_src/328.奇偶链表.java) 328.奇偶链表
```
为奇偶链表分别建立双指针
第一个结点作为奇数链的头结点，第二个结点作为偶数链的头结点
遍历完之后，将奇数链的尾结点连接偶数链的头结点，偶数链的尾结点为空，返回奇数链的头
```

[Leetcode Q206](java_src/206.反转链表.java) 206.反转链表
```
两个指针，prev和curr，以及nxt
```

[Leetcode Q92](java_src/92.反转链表II.java) 92.反转链表II
```
本题思路：
基本上就是链表的指针转换+链表反转
反转链表的迭代方法背下来就完事了
```

[Leetcode Q2](java_src/2.两数相加.java) 2.两数相加
```
本题思路：
使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程
```

[Leetcode Q445](java_src/445.两数相加II.java) 445.两数相加II
```
本题思路：
链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，可以使用栈
```

[Leetcode Q160](java_src/160.相交链表.java) 160.相交链表
```
本题思路：
A和B两个链表长度可能不同，但是A+B和B+A的长度是相同的，所以遍历A+B和遍历B+A一定是同时结束。
如果A,B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 
如果A,B不相交的话两个指针就会同时到达A+B（B+A）的尾节点
```

[Leetcode Q203](java_src/203.移除链表元素.java) 203.移除链表元素
```
本题思路：
遍历链表，删除结点
通过哨兵节点来解决删除链表头部的结点
用prev的原因，curr遍历时，比较了val才知道这个结点需要移除，这时候就需要prev
```

[Leetcode Q19](java_src/19.删除链表的倒数第N个节点.java) 19.删除链表的倒数第N个节点
```
本题思路：
快慢指针，保持快慢指针之间有恒定的间隔
因为涉及到删除结点，很可能删除的是头结点，所以我们用到哨兵结点
```

[剑指Offer22](java_src/剑指Offer22.链表中倒数第k个节点.java) 剑指Offer22.链表中倒数第k个节点
```
本题思路：
快慢指针
```

[Leetcode Q876](java_src/876.链表的中间结点.java) 876.链表的中间结点
```
本题思路：
快慢指针
```

[Leetcode Q83](java_src/83.删除排序链表中的重复元素.java) 83.删除排序链表中的重复元素
```
本题思路：
由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。
如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。
不要用prev的原因：预知需要删除的结点是提前的
```

[Leetcode Q82](java_src/82.删除排序链表中的重复元素II.java) 82.删除排序链表中的重复元素II
```
本题思路：
快慢指针,用快指针跳过那些有重复数组,慢指针负责和快指针拼接!
为了防止删除头结点的极端情况发生，先创建空结点dummy
```

[Leetcode Q138](java_src/138.复制带随机指针的链表.java) 138.复制带随机指针的链表
```
本题思路：
用哈希表存储访问过的结点，key为原结点，value为deepcopy的结点
在迭代链表时，我们只需要为 random 指针和 next 指针指向的未访问过节点创造新的节点并赋值即可。
```

[面试题02.04](java_src/面试题02.04.分割链表.java) 面试题02.04.分割链表
```
本题思路：
使用头插法即可，其中开始循环的节点为head.next，因为head不用判断
```

[Leetcode Q725](java_src/725.分隔链表.java) 725.分隔链表
```
本题思路：
如果链表有N个结点，则分隔的链表中每个部分中都有n/k个结点，且前N%k部分有一个额外的结点。我们可以用一个简单的循环来计算N。
现在对于每个部分，我们已经计算出该部分有多少个节点：width + (i < remainder ? 1 : 0)。我们创建一个新列表并将该部分写入该列表。
```

[Leetcode Q143](java_src/143.重排链表.java) 143.重排链表
```
本题思路：
找到中点
逆转后半部分
拼接前半部分和逆转过的后半部分
```
147. 对链表进行插入排序
25. K 个一组翻转链表
