# 位操作 


[Leetcode Q191](java_src/191.位1的个数.java) 位1的个数 [大佬分析I](https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/chang-yong-de-wei-cao-zuo)
```
不断把数字最后一个 1 反转，并把答案加一。当数字变成 0 的时候偶，我们就知道它没有 1 的位了，此时返回答案。

这里关键的想法是对于任意数字 n ，将 n 和 n−1 做与运算，会把最后一个 1 的位变成 00 。为什么？考虑 n 和 n−1 的二进制表示。

在二进制表示中，数字 n 中最低位的 1 总是对应 n−1 中的 0 。因此，将 n 和 n−1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。

```

[Leetcode Q231](java_src/231.2的幂.java) 2的幂 [大佬分析I](https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/chang-yong-de-wei-cao-zuo)
```
一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：
2 的幂二进制表示只含有一个 1。
x & (x - 1) 操作会将 2 的幂设置为 0，因此判断是否为 2 的幂是：判断 x & (x - 1) == 0。
```

[Leetcode Q338](java_src/338.比特位计数.java) 338.比特位计数
```
    // 本题思路：
    // 遍历一遍，计算每个数二进制1的个数
    // 计算二进制1的个数：
    // 因为n&(n-1)可以消除最后一个1，所以可以用一个循环不停地消除1同时计数，直到n变成0为止。
```

[Leetcode Q461](java_src/461.汉明距离.java) 461.汉明距离
```
    // 本题思路：
    // 两个整数之间的汉明距离是对应位置上数字不同的位数。
    // 根据以上定义，提出一种 XOR 的位运算，当且仅当输入位不同时输出为 1。
    // 计算 x 和 y 之间的汉明距离，可以先计算 x OR y，然后统计结果中等于 1 的位数。
```

[Leetcode Q136](java_src/136.只出现一次的数字.java) 136.只出现一次的数字
```
    // 本题思路：
    // 使用位运算。对于这道题，可使用异或运算。异或运算有以下三个性质。
    // 任何数和 0 做异或运算，结果仍然是原来的数
    // 任何数和其自身做异或运算，结果是 0
    // 异或运算满足交换律和结合律
```

[剑指Offer15](java_src/剑指Offer15.二进制中1的个数.java) 剑指 Offer 15. 二进制中1的个数
```
    // 本题思路：
    // 位运算，每一步去除该数字二进制最后一个1
```
